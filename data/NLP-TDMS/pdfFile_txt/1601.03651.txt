section: title
Improved Relation Classification by Deep Recurrent Neural Networks with Data Augmentation
section: abstract
Nowadays, neural networks play an important role in the task of relation classification. By designing different neural architectures, researchers have improved the performance to a large extent in comparison with traditional methods. However, existing neural networks for relation classification are usually of shallow architectures (e.g., one-layer convolutional neural networks or recurrent networks). They may fail to explore the potential representation space in different abstraction levels. In this paper, we propose deep recurrent neural networks (DRNNs) for relation classification to tackle this challenge. Further, we propose a data augmentation method by leveraging the directionality of relations. We evaluated our DRNNs on the SemEval-2010 Task 8, and achieve an F 1-score of 86.1%, outperforming previous state-of-the-art recorded results. 1
section: Introduction
Classifying relations between two entities in a given context is an important task in natural language processing (NLP). Take the following sentence as an example: "Jewelry and other smaller e 1 were locked in a e 2 or a closet with a deadbolt." The marked entities valuables and safe are of relation Content-Container(e 1 , e 2 ). Relation classification plays a key role in various NLP applications, and has become a hot research topic in recent years.
Nowadays, neural network-based approaches have made significant improvement in relation classification, compared with traditional methods based on either human-designed features) or kernels (. For example, and utilize convolutional neural networks (CNNs) for relation classification. apply long short term memory (LSTM)-based recurrent neural networks (RNNs) along the shortest dependency path. build ensembles of gated recurrent unit (GRU)-based RNNs and CNNs.
We have noticed that these neural models are typically designed in shallow architectures, e.g., one layer of CNN or RNN, whereas evidence in the deep learning community suggests that deep architectures are more capable of information integration and abstraction (). A natural question is then whether such deep architectures are beneficial to the relation classification task.
In this paper, we propose the deep recurrent neural networks (DRNNs) to classify relations. The deep RNNs can explore the representation space in different levels of abstraction and granularity. By visualizing how RNN units are related to the ultimate classification, we demonstrate that different layers indeed learn different representations: low-level layers enable sufficient information mix, while highlevel layers are more capable of precisely locating the information relevant to the target relation between * Equal contribution. [safe] two entities. Following our previous work (), we leverage the shortest dependency path (SDP,) as the backbone of our RNNs.
We further observe that the relationship between two entities are directed. Two sub-paths, separated by entities' common ancestor, can be mapped to subject-predicate and object-predicate components of a relation. By changing the order of these two sub-paths, we obtain anew data sample with the inversed relationship (. Such data augmentation technique can provide additional data samples without using external data resources.
We evaluated our proposed method on the SemEval-2010 relation classification task. Even if we do not apply data augmentation, the DRNNs model has achieved a high performance of 84.2% F 1 -score with a depth of 3, but the performance decreases when the depth is too large. This is because the deep RNN is a large model, which necessitates more data samples for training. Applying data augmentation can alleviate the problem of data sparseness and sustain a deeper RNN to improve the performance to 86.1%. The results show that both our deep networks and the data augmentation strategy have contributed to the relation classification task, and that they are coupled well together for further performance improvement.
The rest of this paper is organized as follows. Section 2 reviews related work; Section 3 describes our DRNNs model in detail. Section 4 presents in-depth experimental results. Finally, we have conclusion in Section 5.
section: Related Work
Traditional methods for relation classification mainly fall into two groups: feature-based or kernel-based. The former approaches extract different types of features and feed them into a classifier, e.g., a maximum entropy model). Various features, including lexical, syntactic, as well as semantic ones, are shown to be useful to relation classification (. By contrast, kernel-based methods do not have explicit feature representations, but require predefined similarity measure of two data samples. design a kernel along the shortest dependency path (SDP) between two entities by observing that the relation strongly relies on SDPs. combine structural information and semantic information in a tree kernel.
Neural networks have now become a prevailing technique in this task. Socher et al. (2011) design a recursive neural network along the constituency parse tree., also on the basis of recursive networks, emphasize more on important phrases; restrict recursive networks to SDP. In our previous study (), we introduce SDP-based recurrent neural network to classify relations., on the other hand, apply CNNs to relation classification. Along this line, dos replace the common softmax loss function with a ranking loss in their CNN model. design a negative sampling method for SDP-based CNNs.
Besides, representative hybrid models of CNNs and recursive/recurrent networks include and.
section: The Proposed Methodology
In this section, we describe our methodology in detail. Subsection 3.1 provides an overall picture of our DRNNs model. Subsections 3.2 and 3.3 describe deep recurrent neural networks. The proposed data augmentation technique is introduced in Subsection 3.4. Finally, we present our training objective in Subsection 3.5. depicts the overall architecture of the DRNNs model. Given a sentence and its dependency parse tree, 1 we follow our previous work () and build DRNNs on the shortest dependency path (SDP), which serves as a backbone. In particular, an RNN picks up information along each sub-path, separated by the common ancestor of marked entities. Also, we take advantage of four information channels, namely, word embeddings, POS embeddings, grammatical relation embeddings, and WordNet embeddings.
section: Overview
Different from, we design deep RNNs with up to four hidden layers so as to capture information in different levels of abstraction. For each RNN layer, max pooling gathers information from different recurrent nodes. Notice that the four channels (with eight sub-paths) are processed in a similar way. Then all pooling layers are concatenated and fed into a hidden layer for information integration. Finally, we have a softmax output layer for classification.
section: Recurrent Neural Networks on Shortest Dependency Path
In this subsection, we introduce a single layer of RNN based on SDP, serving as a building block of our deep architecture.
Compared with a raw word sequence or a whole parse tree, the shortest dependency path (SDP) between two entities has two main advantages. First, it reduces irrelevant information; second, grammatical relations between words focus on the action and agents in a sentence and are naturally suitable for relation classification. Existing studies have demonstrated the effectiveness of SDP Focused on the SDP, an RNN keeps a hidden state vector h, changing with the input word at each step accordingly. Concretely, the hidden state ht , for the t-th word in the sub-path, depends on its previous state h t−1 and the current word's embedding x t . For the simplicity and without loss of generality, we use vanilla recurrent networks with perceptron-like interaction, that is, the input is linearly transformed by a weight matrix and non-linearly squashed by an activation function, i.e.,
where W in and W rec are weight matrices for the input and recurrent connections, respectively. b h is a bias term, and f is a non-linear activation function (ReLU in our experiment).
section: Deep Recurrent Neural Networks
Although an RNN, as described above, is suitable for picking information along a sequence (a subpath in our task) by its iterative nature, the machine learning community suggests that deep architectures maybe more capable of information integration, and can capture different levels of abstraction. A single-layer RNN can be viewed that it is deep along time steps. When unfolded, however, the RNN has only one hidden layer to capture the current input, as well as to retain the information in its previous step. In this sense, single-layer RNNs are actually shallow in information processing). ...
section: Softmax
section: Word/GR/POS/WordNet embeddings
section: Hidden layer
Figure 2: The overall architecture of DRNNs. Two recurrent neural networks pickup information along the shortest dependency path, separated by its common ancestor. We use four information channels, namely words, part-of-speech tags, grammatical relations (GR), and WordNet hypernyms.
In the relation classification task, words along SDPs provide information from different perspectives. On the one hand, the marked entities themselves are informative. On the other hand, the entities' common ancestor (typically verbs) tells how the two entities are related to each other. Such heterogeneous information might necessitate more complex machinery than a single RNN layer.
Following such intuition, we investigate deep RNNs by stacking multiple hidden layers on the top of one another, that is, every layer treats its previous layer as input, and computes its activation similar to Equation 1. Formally, we have
where the subscripts refer to time steps, and superscripts indicate the layer number. To enhance information propagation, we add a "cross" connection for hidden layers (i ≥ 2) from the lower layer in the previous time step, given by W
(See also and arrows in).
section: Data Augmentation
Neural networks, especially deep ones, are likely to be prone to overfitting. The SemEval-2010 relation classification dataset, we use, comprises only several thousand samples, which may not fully sustain the training of deep RNNs.
To mitigate this problem, we propose a data augmentation technique for relation classification by making use of the directionality of relationships.
The two sub-paths, for example, can be mapped to the subject-predicate and object-predicate components in the relation Content-Container(e 1 , e 2 ). If we change the order of these two subpaths, we obtain
Then the relationship becomes Container-Content(e 1 , e 2 ), which is exactly the inverse of Content-Container(e 1 , e 2 ). In this way, we can augment the dataset without using additional resources.
section: Training Objective
For each recurrent layer and embedding layer (over each sub-path for each channel), we apply a max pooling layer to gather information. In total, we have 40 pools, which are concatenated and fed to a hidden layer for information integration.
Finally, a softmax layer outputs the estimated probability that two sub-paths (s left and s right ) are of relation r. For a single data sample i, we apply the standard cross-entropy loss, denoted as J(s left i , s right i
, r i ). With the data augmentation technique, our overall training objective is
where r −1 refers to the inverse of relation r. m is the number of data samples in the original training set. ω is the number of weight matrices in DRNNs. λ is a regularization coefficient, and · F denotes Frobenius norm of a matrix. For decoding (predicting the relation of an unseen sample), the data augmentation technique provides new opportunities, because we can use the probability of r(e 1 , e 2 ), r −1 (e 2 , e 1 ), or both. Section 4.3 provides detailed discussion.
section: Experiments
In this section, we present our experiments in detail. Subsection 4.1 introduces the dataset; Subsection 4.2 describes hyperparameter settings. We discuss the details of data augmentation in Subsection 4.3 and the rationale for using RNNs in Subsection 4.4. Subsection 4.5 compares our DRNNs model with other methods in the literature. In Subsection 4.6, we have quantitative and qualitative analysis of how the depth affects our model.
section: Dataset
We evaluated our DRNNs model on the SemEval-2010 Task 8 dataset, which is an established benchmark for relation classification). The dataset contains 8000 sentences for training, and 2717 for testing. We split 800 samples out of the training set for validation.
There are 9 directed relations and an undirected default relation Other; thus, we have 19 different labels in total. However, the Other class is not taken into consideration when we compute the official measures.
section: Hyperparameter Settings
This subsection presents hyperparameters of our proposed model. We basically followed the settings in our previous work (). Word embeddings were 200-dimensional, pretrained ourselves using word2vec () on the Wikipedia corpus; embeddings in other channels were 50-dimensional initialized randomly. The hidden layers in each channel had the same number of units as their embeddings (either 200 or 50); the penultimate hidden layer was 100-dimensional. An 2 penalty of 10 −5 was also applied as in, but we chose the dropout rate by validation with a granularity of 5% for our model variants (with different depths).
We also chose the depth of DRNNs by validation from the set {1, 2, · · · , 6}. The 3-layer and 4-layer DRNNs yield the highest performance with and without data augmentation, respectively. Section 4.6 provides both quantitative and qualitative analysis regarding the effect of depth.
We applied mini-batched stochastic gradient descent for optimization, where gradients were computed by standard back-propagation.: Comparing CNNs and RNNs (also using F 1 -score as the measurement).
section: Variant of Data augmentation
section: Data Augmentation Details
As mentioned in Section 4.1, the SemEval-2010 Task 8 dataset contains an undirected class Other in addition to 9 directed relations (18 classes). For data augmentation, it is natural that the inversed
Other relation is also in the Other class itself. However, if we augment all the relations, we observe a performance degradation of 0.7%. We deem the Other class contains mainly noise, and is inimical to our model. Then we conducted another experiment where we only augmented the Other class. The result verifies our conjecture as we obtained an even larger degradation of 1.1% in this setting.
The pilot experiments suggest that we should take into consideration unfavorable noise when performing data augmentation. In this experiment, if we reverse the directed relations only and leave the Other class intact, the performance is improved by a large margin of 1.9%. This shows that our proposed data augmentation technique does help to mitigate the problem of data sparseness, if we carefully rule out the impact of noise.
During validation and testing, we shall decode the target label of an unseen data sample (with two entities e 1 and e 2 ). Through data augmentation, we are equipped with the probability of r −1 (e 2 , e 1 ) in addition to r(e 1 , e 2 ). In our experiment, we tried several settings and chose to user −1 (e 2 , e 1 ) only, because it yields the highest the validation result. We think this is probably because the Other class brings more noise tor than r −1 , as the Other class is not augmented (and hence asymmetric).
We would like to point out that our data augmentation method is a general technique for relation classification, which is not ad hoc to a specific dataset; that the methodology for dealing with noise is also potentially applicable to other datasets.
section: RNNs vs. CNNs
As both RNNs and CNNs are prevailing neural models for NLP, we are curious whether deep architectures are also beneficial to CNNs. We tried a CNN with a sliding window of size 3 based on SDPs, similar to; other settings were as our DRNNs.
The results are shown in. We observe that a single layer of CNN is also effective, yielding an F 1 -score slightly worse than our RNN. But the deep architecture hurts the performance of CNNs in this task. One plausible explanation is that, when convolution is performed, the beginning and end of a sentence are typically padded with a special symbol or simply zero. However, the shortest dependency path between two entities is usually not very long (∼4 on average). Hence, sentence boundaries may play a large role in convolution, which makes CNNs vulnerable.
On the contrary, RNNs can deal with sentence boundaries smoothly, and the performance continues to increase with up to 4 hidden layers. (Details are deferred to Subsection 4.6.) compares our DRNNs model with previous state-of-the-art methods. The first entry in the table presents the highest performance achieved by traditional feature-based methods. feed a variety of handcrafted features to the SVM classifier and achieve an F 1 -score of 82.2%.
section: Overall Performance
Recent performance improvements on this dataset are mostly achieved with the help of neural networks. In an early study, build a recursive network on constituency trees, but   achieve a performance worse than. They extend their recursive network with matrix-vector interaction and elevate the F 1 -score to 82.4%. restrict the recursive network to SDP, which is slightly better than a sentence-wide network. In our previous study (), we introduce recurrent neural networks based on SDP and improve the F 1 -score to 83.7%.
In the school of convolution, construct a CNN on the word sequence; they also integrate word position embeddings, which benefit the CNN architecture. dos propose a similar CNN model, named CR-CNN, by replacing the common softmax cost function with a ranking-based cost function. By diminishing the impact of the Other class, they achieve an F 1 -score of 84.1%. design an SDP-based CNN with negative sampling, improving the performance to 85.6%.
Hybrid models of CNNs and RNNs do not appear to be very useful, achieving up to an F 1 -score of 84.1% (. propose a Feature-rich Compositional Embedding Model (FCM), which combines unlexicalized linguistic contexts and word embeddings. They do not use neural networks (at least in the usual sense) and achieve an F 1 -score of 83.0%.
Our DRNNs model, along with data augmentation, achieves an F 1 -score of 86.1%. Even if we do not apply data augmentation, the DRNNs model yields 84.2% F 1 -score, which is also the highest score achieved without special treatment to the noisy Other class. The above results show the effectiveness of DRNNs, especially trained with a large (augmented) dataset.
section: Analysis of DRNNs' Depth
In this subsection, we analyze the effect of depth in our DRNNs model. We have tested the depth from the set {1, 2, · · · , 6}, and plot the results in. Initially, the performance increases if the depth is larger in both settings with and without augmentation. However, if we do not augment data, the performance peaks when the depth is 3. Provided with augmented training samples, the F 1 -score continues to increase with up to 4 layers, and ends up with an F 1 -score of 86.1%.
We next investigate how RNN units in different layers are related to the ultimate task of interest. This is accomplished by tracing back information from pooling layers. Noticing that the pooling layer takes maximum value in each dimension, we can compute how much a hidden layer's units are gathered by pooling for further processing. In this way, we are able to demonstrate the information flow in RNN hidden units. We plot three examples in. Here, rectangles refer to RNN hidden layers, unfolded along time. (Rounded rectangles are word embeddings.) The intensity of color reflects the ratio of the pooling proportion.
• Sample 1: "Until 1864 e 1 in the service of certain UK public offices defaced the Red Ensign with the [badge] e 2 of their office" with label Instrument-Agency(e 2 , e 1 ). Its two sub-paths of SDP are
From, we see that entities like vessels and badge are darker than the verb phrase defaced with on the embedding layer. When information is propagating horizontally and vertically, these entities are getting lighter, while the verb phrase becomes darker gradually. Intuitively, we think that, considering the relation Instrument-Agency(e 2 , e 1 ), it is less informative with only two entities vessels and badge. When adding the semantic of verb phrase defaced with, we are more aware of the target relation. 3
• Sample 2: "Most of the [verses] e 1 of the plantation songs had some reference to [freedom] e 2 " with label Message-Topic(e 1 , e 2 ). Its two sub-paths of SDP are
Similar to Sample 1, we see from that the color of the "pivot" verb had is getting darker vertically, and becomes the darkest in the fourth RNN layer, indicating the highest pooling portion. This is probably because had links two ends of the relation, Message and Topic.
• MaTIIInstrument-AgencyMe2,Ie1T
McTIIComponent-WholeMe1,Ie2T MbTIIMessage-TopicMe1,Ie2T
Figure 4: Visualization of information propagation along multiple RNN layers.
We summarize our findings as follows. Pooled information usually peaks atone or a few words in the embedding layer. This makes sense because there is no information flow in this layer. (2) Information scatters over a wider range in hidden layers, showing that the recurrent propagation does mix information. (3) For a higher-level layer, the network pays more attention to those words that are more relevant to the relation, but whether entities or their common ancestor is more relevant is not consistent among different data samples.
section: Conclusion
In this paper, we proposed deep recurrent neural networks, named DRNNs, to improve the performance of relation classification. The DRNNs model, consisting of several RNN layers, explores the representation space of different abstraction levels. By visualizing DRNNs' units, we demonstrated that high-level layers are more capable of integrating information relevant to target relations. In addition, we have designed a data augmentation strategy by leveraging the directionality of relations. When evaluated on the SemEval dataset, our DRNNs model results in substantial performance boost. The performance generally improves when the depth increases; with a depth of 4, our model reaches the highest F 1 -measure of 86.1%.
