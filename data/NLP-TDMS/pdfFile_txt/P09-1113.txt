section: title
Distant supervision for relation extraction without labeled data
section: abstract
Modern models of relation extraction for tasks like ACE are based on supervised learning of relations from small hand-labeled corpora. We investigate an alternative paradigm that does not require labeled corpora, avoiding the domain dependence of ACE-style algorithms, and allowing the use of corpora of any size. Our experiments use Freebase, a large semantic database of several thousand relations, to provide distant supervision. For each pair of entities that appears in some Freebase relation, we find all sentences containing those entities in a large un-labeled corpus and extract textual features to train a relation classifier. Our algorithm combines the advantages of supervised IE (combining 400,000 noisy pattern features in a probabilistic classifier) and unsupervised IE (extracting large numbers of relations from large corpora of any domain). Our model is able to extract 10,000 instances of 102 relations at a precision of 67.6%. We also analyze feature performance, showing that syntactic parse features are particularly helpful for relations that are ambiguous or lexically distant in their expression.
section: Introduction
At least three learning paradigms have been applied to the task of extracting relational facts from text (for example, learning that a person is employed by a particular organization, or that a geographic entity is located in a particular region).
In supervised approaches, sentences in a corpus are first hand-labeled for the presence of entities and the relations between them. The NIST Automatic Content Extraction (ACE) RDC 2003 and 2004 corpora, for example, include over 1,000 documents in which pairs of entities have been labeled with 5 to 7 major relation types and 23 to 24 subrelations, totaling 16,771 relation instances. ACE systems then extract a wide variety of lexical, syntactic, and semantic features, and use supervised classifiers to label the relation mention holding between a given pair of entities in a test set sentence, optionally combining relation mentions (.
Supervised relation extraction suffers from a number of problems, however. Labeled training data is expensive to produce and thus limited in quantity. Also, because the relations are labeled on a particular corpus, the resulting classifiers tend to be biased toward that text domain.
An alternative approach, purely unsupervised information extraction, extracts strings of words between entities in large amounts of text, and clusters and simplifies these word strings to produce relation-strings (;. Unsupervised approaches can use very large amounts of data and extract very large numbers of relations, but the resulting relations may not be easy to map to relations needed fora particular knowledge base.
A third approach has been to use a very small number of seed instances or patterns to do bootstrap learning;. These seeds are used with a large corpus to extract anew set of patterns, which are used to extract more instances, which are used to extract more patterns, in an iterative fashion. The resulting patterns often suffer from low precision and semantic drift.
We propose an alternative paradigm, distant supervision, that combines some of the advantages of each of these approaches. Distant supervision is an extension of the paradigm used by for exploiting WordNet to extract hypernym (is-a) relations between entities, and is similar to the use of weakly labeled data in bioinformatics Relation Upton Sinclair, Lanny Budd /business/company/founders WWE, Vince McMahon /people/person/profession Thomas Mellon, judge: Ten relation instances extracted by our system that did not appear in Freebase.
2004). Our algorithm uses Freebase (, a large semantic database, to provide distant supervision for relation extraction. Freebase contains 116 million instances of 7,300 relations between 9 million entities. The intuition of distant supervision is that any sentence that contains a pair of entities that participate in a known Freebase relation is likely to express that relation in someway. Since there maybe many sentences containing a given entity pair, we can extract very large numbers of (potentially noisy) features that are combined in a logistic regression classifier. Thus whereas the supervised training paradigm uses a small labeled corpus of only 17,000 relation instances as training data, our algorithm can use much larger amounts of data: more text, more relations, and more instances. We use 1.2 million Wikipedia articles and 1.8 million instances of 102 relations connecting 940,000 entities. In addition, combining vast numbers of features in a large classifier helps obviate problems with bad features.
Because our algorithm is supervised by a database, rather than by labeled text, it does not suffer from the problems of overfitting and domain-dependence that plague supervised systems. Supervision by a database also means that, unlike in unsupervised approaches, the output of our classifier uses canonical names for relations.
Our paradigm offers a natural way of integrating data from multiple sentences to decide if a relation holds between two entities. Because our algorithm can use large amounts of unlabeled data, a pair of entities may occur multiple times in the test set. For each pair of entities, we aggregate the features from the many different sentences in which that pair appeared into a single feature vector, allowing us to provide our classifier with more information, resulting in more accurate labels. shows examples of relation instances extracted by our system. We also use this system to investigate the value of syntactic versus lexical (word sequence) features in relation extraction. While syntactic features are known to improve the performance of supervised IE, at least using clean hand-labeled ACE data (), we do not know whether syntactic features can improve the performance of unsupervised or distantly supervised IE. Most previous research in bootstrapping or unsupervised IE has used only simple lexical features, thereby avoiding the computational expense of parsing, and the few systems that have used unsupervised IE have not compared the performance of these two types of feature.
section: Previous work
Except for the unsupervised algorithms discussed above, previous supervised or bootstrapping approaches to relation extraction have typically relied on relatively small datasets, or on only a small number of distinct relations. Approaches based on WordNet have often only looked at the hypernym (is-a) or meronym (part-of) relation (), while those based on the ACE program () have been restricted in their evaluation to a small number of relation instances and corpora of less than a million words.
Many early algorithms for relation extraction used little or no syntactic information. For example, the DIPRE algorithm by used string-based regular expressions in order to recognize relations such as author-book, while the SNOWBALL algorithm by learned similar regular expression patterns over words and named entity tags. used a small number of regular expressions over words and part-of-speech tags to find examples of the hypernym relation. The use of these patterns has been widely replicated in successful systems, for example by  More recent approaches have used deeper syntactic information derived from parses of the input sentences, including work exploiting syntactic dependencies by and, and work in the ACE paradigm such as and.
Perhaps most similar to our distant supervision algorithm is the effective method of who extract relations from a Wikipedia page by using supervision from the page's infobox. Unlike their corpus-specific method, which is specific to a (single) Wikipedia page, our algorithm allows us to extract evidence fora relation from many different documents, and from any genre.
section: Freebase
Following the literature, we use the term 'relation' to refer to an ordered, binary relation between entities. We refer to individual ordered pairs in this relation as 'relation instances'. For example, the person-nationality relation holds between the entities named 'John Steinbeck' and 'United States', so it has John Steinbeck, United States as an instance.
We use relations and relation instances from Freebase, a freely available online database of structured semantic data. Data in Freebase is collected from a variety of sources. One major source is text boxes and other tabular data from Wikipedia. Data is also taken from NNDB (biographical information), MusicBrainz (music), the SEC (financial and corporate data), as well as direct, wiki-style user editing. After some basic processing of the July 2008 link export to convert Freebase's data representation into binary relations, we have 116 million instances of 7,300 relations between 9 million entities. We next filter out nameless and uninteresting entities such as user profiles and music tracks. Freebase also contains the reverses of many of its relations (bookauthor v. author-book), and these are merged. Filtering and removing all but the largest relations leaves us with 1.8 million instances of 102 relations connecting 940,000 entities. Examples are shown in.
section: Architecture
The intuition of our distant supervision approach is to use Freebase to give us a training set of relations and entity pairs that participate in those relations. In the training step, all entities are identified in sentences using a named entity tagger that labels persons, organizations and locations. If a sentence contains two entities and those entities are an instance of one of our Freebase relations, features are extracted from that sentence and are added to the feature vector for the relation.
The distant supervision assumption is that if two entities participate in a relation, any sentence that contain those two entities might express that relation. Because any individual sentence may give an incorrect cue, our algorithm trains a multiclass logistic regression classifier, learning weights for each noisy feature. In training, the features for identical tuples (relation, entity1, entity2) from different sentences are combined, creating a richer feature vector.
In the testing step, entities are again identified using the named entity tagger. This time, every pair of entities appearing together in a sentence is considered a potential relation instance, and whenever those entities appear together, features are extracted on the sentence and added to a feature vector for that entity pair. For example, if a pair of entities occurs in 10 sentences in the test set, and each sentence has 3 features extracted from it, the entity pair will have 30 associated features. Each entity pair in each sentence in the test corpus is run through feature extraction, and the regression classifier predicts a relation name for each entity pair based on the features from all of the sentences in which it appeared.
Consider the location-contains relation, imagining that in Freebase we had two instances of this relation: Virginia, Richmond and France, Nantes. As we encountered sentences like 'Richmond, the capital of Virginia' and 'Henry's Edict of Nantes helped the Protestants of France' we would extract features from these sentences. Some features would be very useful, such as the features from the Richmond sentence, and some would be less useful, like those from the Nantes sentence. In testing, if we came across a sentence like 'Vienna, the capital of Austria', one or more of its features would match those of the Richmond sentence, providing evidence that Austria, Vienna belongs to the locationcontains relation.
Note that one of the main advantages of our architecture is its ability to combine information from many different mentions of the same relation. Consider the entity pair Steven Spielberg, Saving Private Ryan from the following two sentences, as evidence for the film-director relation.
[Steven Spielberg]'s film is loosely based on the brothers' story.
Allison co-produced the Academy Awardwinning, directed by...
The first sentence, while providing evidence for film-director, could instead be evidence for filmwriter or film-producer. The second sentence does not mention that Saving Private Ryan is a film, and so could instead be evidence for the CEO relation (consider 'Robert Mueller directed the FBI'). In isolation, neither of these features is conclusive, but in combination, they are.
section: Features
Our features are based on standard lexical and syntactic features from the literature. Each feature describes how two entities are related in a sentence, using either syntactic or non-syntactic information.
section: Lexical features
Our lexical features describe specific words between and surrounding the two entities in the sentence in which they appear: Each lexical feature consists of the conjunction of all these components. We generate a conjunctive feature for each k ∈ {0, 1, 2}. Thus each lexical row in represents a single lexical feature. Part-of-speech tags were assigned by a maximum entropy tagger trained on the Penn Treebank, and then simplified into seven categories: nouns, verbs, adverbs, adjectives, numbers, foreign words, and everything else.
In an attempt to approximate syntactic features, we also tested variations on our lexical features: (1) omitting all words that are not verbs and (2) omitting all function words. In combination with the other lexical features, they gave a small boost to precision, but not large enough to justify the increased demand on our computational resources.
section: Syntactic features
In addition to lexical features we extract a number of features based on syntax. In order to generate these features we parse each sentence with the broad-coverage dependency parser MINIPAR. A dependency parse consists of a set of words and chunks (e.g. 'Edwin Hubble', 'Missouri', 'born'), linked by directional dependencies (e.g. 'pred', 'lex-mod'), as in. For each sentence we extract a dependency path between each pair of entities. A dependency path consists of a series of dependencies, directions and words/chunks representing a traversal of the parse. Part-of-speech tags are not included in the dependency path.
Our syntactic features are similar to those used in. They consist of the conjunction of:
• A dependency path between the two entities • For each entity, one 'window' node that is not part of the dependency path A window node is anode connected to one of the two entities and not part of the dependency path. We generate one conjunctive feature for each pair of left and right window nodes, as well as features which omit one or both of them. Thus each syntactic row in represents a single syntactic feature.
section: Named entity tag features
Every feature contains, in addition to the content described above, named entity tags for the two entities. We perform named entity tagging using the Stanford four-class named entity tagger (). The tagger provides each word with a label from {person, location, organization, miscellaneous, none}.
section: Feature conjunction
Rather than use each of the above features in the classifier independently, we use only conjunctive features. Each feature consists of the conjunction of several attributes of the sentence, plus the named entity tags. For two features to match, all of their conjuncts must match exactly. This yields low-recall but high-precision features. With a small amount of data, this approach would be problematic, since most features would only be seen once, rendering them useless to the classifier.
Since we use large amounts of data, even complex features appear multiple times, allowing our highprecision features to work as intended. Features fora sample sentence are shown in.: Examples of high-weight features for several relations. Key: SYN = syntactic feature; LEX = lexical feature; = reversed; NE# = named entity tag of entity.
user pages) which has been sentence-tokenized by Metaweb Technologies, the developers of Freebase. This dump consists of approximately 1.8 million articles, with an average of 14.3 sentences per article. The total number of words (counting punctuation marks) is 601,600,703. For our experiments we use about half of the articles: 800,000 for training and 400,000 for testing. We use Wikipedia because it is relatively upto-date, and because its sentences tend to make explicit many facts that might be omitted in newswire. Much of the information in Freebase is derived from tabular data from Wikipedia, meaning that Freebase relations are more likely to appear in sentences in Wikipedia.
section: Parsing and chunking
Each sentence of this unstructured text is dependency parsed by MINIPAR to produce a dependency graph.
In preprocessing, consecutive words with the same named entity tag are 'chunked', so that Edwin/PERSON Hubble/PERSON becomes [Edwin Hubble]/PERSON. This chunking is restricted by the dependency parse of the sentence, however, in that chunks must be contiguous in the parse (i.e., no chunks across subtrees). This ensures that parse tree structure is preserved, since the parses must be updated to reflect the chunking.
section: Training and testing
For held-out evaluation experiments (see section 7.1), half of the instances of each relation are not used in training, and are later used to compare against newly discovered instances. This means that 900,000 Freebase relation instances are used in training, and 900,000 are held out. These experiments used 800,000 Wikipedia articles in the training phase and 400,000 different articles in the testing phase.
For human evaluation experiments, all 1.8 million relation instances are used in training. Again, we use 800,000 Wikipedia articles in the training phase and 400,000 different articles in the testing phase.
For all our experiments, we only extract relation instances that do not appear in our training data, i.e., instances that are not already in Freebase.
Our system needs negative training data for the purposes of constructing the classifier. Towards this end, we build a feature vector in the training phase for an 'unrelated' relation by randomly selecting entity pairs that do not appear in any Freebase relation and extracting features for them. While it is possible that some of these entity pairs are in fact related but are wrongly omitted from the Freebase data, we expect that on average these false negatives will have a small effect on the performance of the classifier. For performance reasons, we randomly sample 1% of such entity pairs for use as negative training examples. By contrast, in the actual test data, 98.7% of the entity pairs we extract do not possess any of the top 102 relations we consider in Freebase.
We use a multi-class logistic classifier optimized using L-BFGS with Gaussian regularization. Our classifier takes as input an entity pair and a feature vector, and returns a relation name and a confidence score based on the probability of the entity pair belonging to that relation. Once all of the entity pairs discovered during testing have been classified, they can be ranked by confidence score and used to generate a list of then most likely new relation instances. shows some high-weight features learned by our system. We discuss the results in the next section.
section: Evaluation
We evaluate labels in two ways: automatically, by holding out part of the Freebase relation data during training, and comparing newly discovered relation instances against this held-out data, and manually, having humans who look at each positively labeled entity pair and mark whether the relation indeed holds between the participants. Both evaluations allow us to calculate the precision of the system for the best N instances. shows the performance of our classifier on held-out Freebase relation data. While held-out evaluation suffers from false negatives, it gives a rough measure of precision without requiring expensive human evaluation, making it useful for parameter setting.
section: Held-out evaluation
At most recall levels, the combination of syntactic and lexical features offers a substantial improvement in precision over either of these feature sets on its own.
section: Human evaluation
Human evaluation was performed by evaluators on Amazon's Mechanical Turk service, shown to be effective for natural language annotation in. We ran three experiments: one using only syntactic features; one using only lexical features; and one using both syntactic and lexical features. For each of the 10 relations that appeared most frequently in our test data (according to our classifier), we took samples from the first 100 and 1000 instances of this relation generated in each experiment, and sent these to Mechanical Turk for human evaluation. Our sample size was 100.
Each predicted relation instance was labeled as true or false by between 1 and 3 labelers on Mechanical Turk. We assigned the truth or falsehood of each relation according to the majority vote of the labels; in the case of a tie (one vote each way) we assigned the relation as true or false with equal probability. The evaluation of the syntactic, lexical, and combination of features at a recall of 100 and 1000 instances is presented in.
At a recall of 100 instances, the combination of lexical and syntactic features has the best performance fora majority of the relations, while at a recall level of 1000 instances the results are mixed. No feature set strongly outperforms any of the others across all relations.
section: Discussion
Our results show that the distant supervision algorithm is able to extract high-precision patterns fora reasonably large number of relations.
The held-out results in suggest that the combination of syntactic and lexical features provides better performance than either feature set on its own. In order to understand the role of syntactic features, we examine, the human evaluation of the most frequent 10 relations. For the topranking 100 instances of each relation, most of the best results use syntactic features, either alone or in combination with lexical features. For the topranking 1000 instances of each relation, the results are more mixed, but syntactic features still helped inmost classifications.
We then examine those relations for which syntactic features seem to help. For example, syntactic features consistently outperform lexical features for the director-film and writer-film relations. As discussed in section 4, these two relations are particularly ambiguous, suggesting that syntactic features may help tease apart difficult relations. Perhaps more telling, we noticed many examples with along string of words between the director and the film:
Back Street is a 1932 film made by Universal Pictures, directed by John M. Stahl, and produced by Carl Laemmle Jr.
Sentences like this have very long (and thus rare) lexical features, but relatively short dependency paths. Syntactic features can more easily abstract from the syntactic modifiers that comprise the extraneous parts of these strings.
Our results thus suggest that syntactic features are indeed useful in distantly supervised information extraction, and that the benefit of syntax occurs in cases where the individual patterns are particularly ambiguous, and where they are nearby in the dependency structure but distant in terms of words. It remains for future work to see whether simpler, chunk-based syntactic features might be able to capture enough of this gain without the overhead of full parsing, and whether coreference resolution could improve performance.
