<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/yhou/git/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-02-07T09:11+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Simple and Accurate Dependency Parsing Using Bidirectional LSTM Feature Representations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eliyahu</forename><surname>Kiperwasser</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Computer Science Department Bar</orgName>
								<orgName type="department" key="dep2">Computer Science Department Bar</orgName>
								<orgName type="institution">Ilan University Ramat-Gan</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
							<email>yoav.goldberg@gmail.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Ilan University Ramat-Gan</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Simple and Accurate Dependency Parsing Using Bidirectional LSTM Feature Representations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We present a simple and effective scheme for dependency parsing which is based on bidirectional-LSTMs (BiLSTMs). Each sentence token is associated with a BiLSTM vector representing the token in its sentential context , and feature vectors are constructed by concatenating a few BiLSTM vectors. The BiLSTM is trained jointly with the parser objective , resulting in very effective feature ex-tractors for parsing. We demonstrate the effectiveness of the approach by applying it to a greedy transition-based parser as well as to a globally optimized graph-based parser. The resulting parsers have very simple architec-tures, and match or surpass the state-of-the-art accuracies on English and Chinese.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The focus of this paper is on feature representation for dependency parsing, using recent techniques from the neural-networks ("deep learning") literature. Modern approaches to dependency parsing can be broadly categorized into graph-based and transition-based parsers ( <ref type="bibr">Kübler et al., 2009)</ref>. Graph-based parsers <ref type="bibr" target="#b33">(McDonald, 2006</ref>) treat parsing as a search-based structured prediction problem in which the goal is learning a scoring function over dependency trees such that the correct tree is scored above all other trees. Transition-based parsers <ref type="bibr" target="#b34">(Nivre, 2004;</ref><ref type="bibr" target="#b35">Nivre, 2008</ref>) treat parsing as a sequence of actions that produce a parse tree, and a classifier is trained to score the possible actions at each stage of the process and guide the parsing process. Perhaps the simplest graph-based parsers are arc-factored (first order) models <ref type="bibr" target="#b33">(McDonald, 2006</ref>), in which the scoring function for a tree decomposes over the individual arcs of the tree. More elaborate models look at larger (overlapping) parts, requiring more sophisticated inference and training algorithms <ref type="bibr" target="#b30">(Martins et al., 2009;</ref><ref type="bibr" target="#b21">Koo and Collins, 2010</ref>). The basic transition-based parsers work in a greedy manner, performing a series of locally-optimal decisions, and boast very fast parsing speeds. More advanced transition-based parsers introduce some search into the process using a beam ( <ref type="bibr" target="#b45">Zhang and Clark, 2008)</ref> or dynamic programming <ref type="bibr" target="#b14">(Huang and Sagae, 2010</ref>).</p><p>Regardless of the details of the parsing framework being used, a crucial step in parser design is choosing the right feature function for the underlying statistical model. Recent work (see Section 2.2 for an overview) attempt to alleviate parts of the feature function design problem by moving from linear to non-linear models, enabling the modeler to focus on a small set of "core" features and leaving it up to the machine-learning machinery to come up with good feature combinations <ref type="bibr">(Chen and Man- ning, 2014;</ref><ref type="bibr" target="#b36">Pei et al., 2015;</ref><ref type="bibr" target="#b27">Lei et al., 2014;</ref><ref type="bibr" target="#b39">Taub- Tabib et al., 2015)</ref>. However, the need to carefully define a set of core features remains. For example, the work of <ref type="bibr" target="#b1">Chen and Manning (2014)</ref> uses 18 different elements in its feature function, while the work of <ref type="bibr" target="#b36">Pei et al. (2015)</ref> uses 21 different elements. Other works, notably <ref type="bibr" target="#b6">Dyer et al. (2015)</ref> and <ref type="bibr" target="#b26">Le and Zuidema (2014)</ref>, propose more sophisticated feature representations, in which the feature engineering is replaced with architecture engineering.</p><p>In this work, we suggest an approach which is much simpler in terms of both feature engineering <ref type="bibr">313</ref> and architecture engineering. Our proposal (Section 3) is centered around BiRNNs ( <ref type="bibr" target="#b15">Irsoy and Cardie, 2014;</ref><ref type="bibr" target="#b37">Schuster and Paliwal, 1997)</ref>, and more specifically BiLSTMs <ref type="bibr" target="#b12">(Graves, 2008)</ref>, which are strong and trainable sequence models (see Section 2.3).</p><p>The BiLSTM excels at representing elements in a sequence (i.e., words) together with their contexts, capturing the element and an "infinite" window around it. We represent each word by its BiLSTM encoding, and use a concatenation of a minimal set of such BiLSTM encodings as our feature function, which is then passed to a non-linear scoring function (multi-layer perceptron). Crucially, the BiLSTM is trained with the rest of the parser in order to learn a good feature representation for the parsing problem. If we set aside the inherent complexity of the BiLSTM itself and treat it as a black box, our proposal results in a pleasingly simple feature extractor.</p><p>We demonstrate the effectiveness of the approach by using the BiLSTM feature extractor in two parsing architectures, transition-based (Section 4) as well as a graph-based (Section 5). In the graphbased parser, we jointly train a structured-prediction model on top of a BiLSTM, propagating errors from the structured objective all the way back to the BiLSTM feature-encoder. To the best of our knowledge, we are the first to perform such end-to-end training of a structured prediction model and a recurrent feature extractor for non-sequential outputs. <ref type="bibr">1</ref> Aside from the novelty of the BiLSTM feature extractor and the end-to-end structured training, we rely on existing models and techniques from the parsing and structured prediction literature. We stick to the simplest parsers in each categorygreedy inference for the transition-based architecture, and a first-order, arc-factored model for the graph-based architecture. Despite the simplicity of the parsing architectures and the feature functions, we achieve near state-of-the-art parsing accuracies in both English (93.1 UAS) and Chinese (86.6 UAS), using a first-order parser with two features and while training solely on Treebank data, without relying on semi-supervised signals such as pre-trained word embeddings <ref type="bibr" target="#b1">(Chen and Manning, 2014)</ref>, word-clusters ( <ref type="bibr" target="#b22">Koo et al., 2008)</ref>, or tech-niques such as tri-training ( <ref type="bibr" target="#b44">Weiss et al., 2015)</ref>. When also including pre-trained word embeddings, we obtain further improvements, with accuracies of 93.9 UAS (English) and 87.6 UAS (Chinese) for a greedy transition-based parser with 11 features, and 93.6 UAS (En) / 87.4 (Ch) for a greedy transitionbased parser with 4 features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Notation</head><p>Notation We use x 1:n to denote a sequence of n vectors x 1 , · · · , x n . F θ (·) is a function parameterized with parameters θ. We write F L (·) as shorthand for F θ L -an instantiation of F with a specific set of parameters θ L . We use • to denote a vector concatenation operation, and v[i] to denote an indexing operation taking the ith element of a vector v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Feature Functions in Dependency Parsing</head><p>Traditionally, state-of-the-art parsers rely on linear models over hand-crafted feature functions. The feature functions look at core components (e.g. "word on top of stack", "leftmost child of the second-totop word on the stack", "distance between the head and the modifier words"), and are comprised of several templates, where each template instantiates a binary indicator function over a conjunction of core elements (resulting in features of the form "word on top of stack is X and leftmost child is Y and . . . "). The design of the feature function -which components to consider and which combinations of components to include -is a major challenge in parser design. Once a good feature function is proposed in a paper it is usually adopted in later works, and sometimes tweaked to improve performance. Examples of good feature functions are the feature-set proposed by Zhang and Nivre (2011) for transitionbased parsing (including roughly 20 core components and 72 feature templates), and the featureset proposed by <ref type="bibr" target="#b32">McDonald et al. (2005)</ref> for graphbased parsing, with the paper listing 18 templates for a first-order parser, while the first order featureextractor in the actual implementation's code (MSTParser 2 ) includes roughly a hundred feature templates.</p><p>The core features in a transition-based parser usually look at information such as the word-identity and part-of-speech (POS) tags of a fixed number of words on top of the stack, a fixed number of words on the top of the buffer, the modifiers (usually leftmost and right-most) of items on the stack and on the buffer, the number of modifiers of these elements, parents of words on the stack, and the length of the spans spanned by the words on the stack. The core features of a first-order graph-based parser usually take into account the word and POS of the head and modifier items, as well as POS-tags of the items around the head and modifier, POS tags of items between the head and modifier, and the distance and direction between the head and modifier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Related Research Efforts</head><p>Coming up with a good feature-set for a parser is a hard and time consuming task, and many researchers attempt to reduce the required manual effort. The work of <ref type="bibr" target="#b27">Lei et al. (2014)</ref> suggests a low-rank tensor representation to automatically find good feature combinations. <ref type="bibr" target="#b39">Taub-Tabib et al. (2015)</ref> suggest a kernel-based approach to implicitly consider all possible feature combinations over sets of core-features. The recent popularity of neural networks prompted a move from templates of sparse, binary indicator features to dense core feature encodings fed into non-linear classifiers. <ref type="bibr" target="#b1">Chen and Manning (2014)</ref> encode each core feature of a greedy transition-based parser as a dense low-dimensional vector, and the vectors are then concatenated and fed into a nonlinear classifier (multi-layer perceptron) which can potentially capture arbitrary feature combinations. <ref type="bibr" target="#b44">Weiss et al. (2015)</ref> showed further gains using the same approach coupled with a somewhat improved set of core features, a more involved network architecture with skip-layers, beam search-decoding, and careful hyper-parameter tuning. <ref type="bibr" target="#b36">Pei et al. (2015)</ref> apply a similar methodology to graph-based parsing. While the move to neural-network classifiers alleviates the need for hand-crafting featurecombinations, the need to carefully define a set of core features remain. For example, the feature representation in <ref type="bibr" target="#b1">Chen and Manning (2014)</ref> is a concatenation of 18 word vectors, 18 POS vectors and 12 dependency-label vectors. <ref type="bibr">3</ref> The above works tackle the effort in hand-crafting effective feature combinations. A different line of work attacks the feature-engineering problem by suggesting novel neural-network architectures for encoding the parser state, including intermediatelybuilt subtrees, as vectors which are then fed to nonlinear classifiers. Titov and Henderson encode the parser state using incremental sigmoid-belief networks <ref type="bibr">(2007)</ref>. In the work of <ref type="bibr" target="#b6">Dyer et al. (2015)</ref>, the entire stack and buffer of a transition-based parser are encoded as a stack-LSTMs, where each stack element is itself based on a compositional representation of parse trees. <ref type="bibr" target="#b26">Le and Zuidema (2014)</ref> encode each tree node as two compositional representations capturing the inside and outside structures around the node, and feed the representations into a reranker. A similar reranking approach, this time based on convolutional neural networks, is taken by <ref type="bibr" target="#b47">Zhu et al. (2015)</ref>. <ref type="bibr">Finally, in Kiperwasser and Gold- berg (2016)</ref> we present an Easy-First parser based on a novel hierarchical-LSTM tree encoding.</p><p>In contrast to these, the approach we present in this work results in much simpler feature functions, without resorting to elaborate network architectures or compositional tree representations.</p><p>Work by <ref type="bibr" target="#b43">Vinyals et al. (2015)</ref> employs a sequence-to-sequence with attention architecture for constituency parsing. Each token in the input sentence is encoded in a deep-BiLSTM representation, and then the tokens are fed as input to a deep-LSTM that predicts a sequence of bracketing actions based on the already predicted bracketing as well as the encoded BiLSTM vectors. A trainable attention mechanism is used to guide the parser to relevant BiLSTM vectors at each stage. This architecture shares with ours the use of BiLSTM encoding and end-to-end training. The sequence of bracketing actions can be interpreted as a sequence of Shift and Reduce operations of a transition-based parser. However, while the parser of Vinyals et al. relies on a trainable attention mechanism for focusing on specific BiLSTM vectors, parsers in the transition-based family we use in Section 4 use a human designed stack and buffer mechanism to manually direct the parser's attention. While the effectiveness of the trainable attention approach is impressive, the stack-and-buffer guidance of transitionbased parsers results in more robust learning. Indeed, work by <ref type="bibr" target="#b4">Cross and Huang (2016)</ref>, published while working on the camera-ready version of this paper, show that the same methodology as ours is highly effective also for greedy, transition-based constituency parsing, surpassing the beam-based architecture of <ref type="bibr">Vinyals et al. (88.3F vs. 89</ref>.8F points) when trained on the Penn Treebank dataset and without using orthogonal methods such as ensembling and up-training.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Bidirectional Recurrent Neural Networks</head><p>Recurrent neural networks (RNNs) are statistical learners for modeling sequential data. An RNN allows one to model the ith element in the sequence based on the past -the elements x 1:i up to and including it. The RNN model provides a framework for conditioning on the entire history x 1:i without resorting to the Markov assumption which is traditionally used for modeling sequences. RNNs were shown to be capable of learning to count, as well as to model line lengths and complex phenomena such as bracketing and code indentation ( <ref type="bibr" target="#b17">Karpathy et al., 2015)</ref>. Our proposed feature extractors are based on a bidirectional recurrent neural network (BiRNN), an extension of RNNs that take into account both the past x 1:i and the future x i:n . We use a specific flavor of RNN called a long short-term memory network (LSTM). For brevity, we treat RNN as an abstraction, without getting into the mathematical details of the implementation of the RNNs and LSTMs. For further details on RNNs and LSTMs, the reader is referred to <ref type="bibr" target="#b11">Goldberg (2015)</ref> and <ref type="bibr" target="#b3">Cho (2015)</ref>.</p><p>The recurrent neural network (RNN) abstraction is a parameterized function RNN θ (x 1:n ) mapping a sequence of n input vectors x 1:n , x i ∈ R d in to a sequence of n output vectors h 1:n , h i ∈ R dout . Each output vector h i is conditioned on all the input vectors x 1:i , and can be thought of as a summary of the prefix x 1:i of x 1:n . In our notation, we ignore the intermediate vectors h 1:n−1 and take the output of RNN θ (x 1:n ) to be the vector h n .</p><p>A bidirectional RNN is composed of two RNNs, RNN F and RNN R , one reading the sequence in its regular order, and the other reading it in reverse. Concretely, given a sequence of vectors x 1:n and a desired index i, the function BIRNN θ (x 1:n , i) is defined as:</p><formula xml:id="formula_0">BIRNN θ (x 1:n , i) = RNN F (x 1:i ) • RNN R (x n:i )</formula><p>The vector v i = BIRNN(x 1:n , i) is then a representation of the ith item in x 1:n , taking into account both the entire history x 1:i and the entire future x i:n by concatenating the matching RNNs. We can view the BiRNN encoding of an item i as representing the item i together with a context of an infinite window around it.</p><p>Computational Complexity Computing the BiRNN vectors encoding of the ith element of a sequence x 1:n requires O(n) time for computing the two RNNs and concatenating their outputs. A naive approach of computing the bidirectional representation of all n elements result in O(n 2 ) computation. However, it is trivial to compute the BiRNN encoding of all sequence items in linear time by pre-computing RNN F (x 1:n ) and RNN R (x n:1 ), keeping the intermediate representations, and concatenating the required elements as needed.</p><p>BiRNN Training Initially, the BiRNN encodings v i do not capture any particular information. During training, the encoded vectors v i are fed into further network layers, until at some point a prediction is made, and a loss is incurred. The back-propagation algorithm is used to compute the gradients of all the parameters in the network (including the BiRNN parameters) with respect to the loss, and an optimizer is used to update the parameters according to the gradients. The training procedure causes the BiRNN function to extract from the input sequence x 1:n the relevant information for the task task at hand.</p><p>Going deeper We use a variant of deep bidirectional RNN (or k-layer BiRNN) which is composed of k BiRNN functions BIRNN 1 , · · · , BIRNN k that feed into each other: the output BIRNN (x 1:n , 1), . . . , BIRNN (x 1:n , n) of BIRNN becomes the input of BIRNN +1 . Stacking <ref type="bibr">316</ref> BiRNNs in this way has been empirically shown to be effective <ref type="bibr" target="#b15">(Irsoy and Cardie, 2014)</ref>. In this work, we use BiRNNs and deep-BiRNNs interchangeably, specifying the number of layers when needed.</p><p>Historical Notes RNNs were introduced by <ref type="bibr">El- man (1990)</ref>, and extended to BiRNNs by <ref type="bibr">Schus- ter and Paliwal (1997)</ref>. The LSTM variant of RNNs is due to <ref type="bibr" target="#b13">Hochreiter and Schmidhuber (1997)</ref>. BiLSTMs were recently popularized by <ref type="bibr" target="#b12">Graves (2008)</ref>, and deep BiRNNs were introduced to NLP by <ref type="bibr" target="#b15">Irsoy and Cardie (2014)</ref>, who used them for sequence tagging. In the context of parsing, <ref type="bibr" target="#b28">Lewis et al. (2016)</ref> and <ref type="bibr" target="#b41">Vaswani et al. (2016)</ref> use a BiLSTM sequence tagging model to assign a CCG supertag for each token in the sentence. <ref type="bibr" target="#b28">Lewis et al. (2016)</ref> feeds the resulting supertags sequence into an A* CCG parser. <ref type="bibr" target="#b41">Vaswani et al. (2016)</ref> adds an additional layer of LSTM which receives the BiLSTM representation together with the k-best supertags for each word and outputs the most likely supertag given previous tags, and then feeds the predicted supertags to a discriminitively trained parser. In both works, the BiLSTM is trained to produce accurate CCG supertags, and is not aware of the global parsing objective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Our Approach</head><p>We propose to replace the hand-crafted feature functions in favor of minimally-defined feature functions which make use of automatically learned Bidirectional LSTM representations.</p><p>Given n-words input sentence s with words w 1 , . . . , w n together with the corresponding POS tags t 1 , . . . , t n , 4 we associate each word w i and POS t i with embedding vectors e(w i ) and e(t i ), and create a sequence of input vectors x 1:n in which each x i is a concatenation of the corresponding word and POS vectors:</p><formula xml:id="formula_1">x i = e(w i ) • e(p i )</formula><p>The embeddings are trained together with the model. This encodes each word in isolation, disregarding its context. We introduce context by representing each input element as its (deep) BiLSTM vector, v i :</p><formula xml:id="formula_2">v i = BILSTM(x 1:n , i)</formula><p>Our feature function φ is then a concatenation of a small number of BiLSTM vectors. The exact feature function is parser dependent and will be discussed when discussing the corresponding parsers. The resulting feature vectors are then scored using a non-linear function, namely a multi-layer perceptron with one hidden layer (MLP):</p><formula xml:id="formula_3">M LP θ (x) = W 2 · tanh(W 1 · x + b 1 ) + b 2 where θ = {W 1 , W 2 , b 1 , b 2 } are the model parame- ters.</formula><p>Beside using the BiLSTM-based feature functions, we make use of standard parsing techniques. Crucially, the BiLSTM is trained jointly with the rest of the parsing objective. This allows it to learn representations which are suitable for the parsing task.</p><p>Consider a concatenation of two BiLSTM vectors (v i • v j ) scored using an MLP. The scoring function has access to the words and POS-tags of v i and v j , as well as the words and POS-tags of the words in an infinite window surrounding them. As LSTMs are known to capture length and sequence position information, it is very plausible that the scoring function can be sensitive also to the distance between i and j, their ordering, and the sequential material between them.</p><p>Parsing-time Complexity Once the BiLSTM is trained, parsing is performed by first computing the BiLSTM encoding v i for each word in the sentence (a linear time operation). 5 Then, parsing proceeds as usual, where the feature extraction involves a concatenation of a small number of the pre-computed v i vectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Transition-based Parser</head><p>We begin by integrating the feature extractor in a transition-based parser <ref type="bibr" target="#b35">(Nivre, 2008)</ref>. We follow the notation in <ref type="bibr" target="#b10">Goldberg and Nivre (2013)</ref>. The Scoring:</p><formula xml:id="formula_4">LST M f xthe concat LST M f xbrown concat LST M f xfox concat LST M f xjumped concat LST M f xover concat LST M f xthe concat LST M f xlazy concat LST M f xdog concat LST M f xROOT concat LST M b s0 LST M b s1 LST M b s2 LST M b s3 LST M b s4 LST M b s5 LST M b s6 LST M b s7 LST M b s8 Vthe Vbrown Vfox Vjumped Vover Vthe Vlazy Vdog VROOT MLP (ScoreLeftArc, ScoreRightArc, ScoreShift)</formula><p>Figure 1: Illustration of the neural model scheme of the transition-based parser when calculating the scores of the possible transitions in a given configuration. The configuration (stack and buffer) is depicted on the top. Each transition is scored using an MLP that is fed the BiLSTM encodings of the first word in the buffer and the three words at the top of the stack (the colors of the words correspond to colors of the MLP inputs above), and a transition is picked greedily. Each x i is a concatenation of a word and a POS vector, and possibly an additional external embedding vector for the word. The figure depicts a single-layer BiLSTM, while in practice we use two layers. When parsing a sentence, we iteratively compute scores for all possible transitions and apply the best scoring action until the final configuration is reached.</p><p>transition-based parsing framework assumes a transition system, an abstract machine that processes sentences and produces parse trees. The transition system has a set of configurations and a set of transitions which are applied to configurations. When parsing a sentence, the system is initialized to an initial configuration based on the input sentence, and transitions are repeatedly applied to this configuration. After a finite number of transitions, the system arrives at a terminal configuration, and a parse tree is read off the terminal configuration. In a greedy parser, a classifier is used to choose the transition to take in each configuration, based on features extracted from the configuration itself. The parsing algorithm is presented in Algorithm 1 below.</p><p>Given a sentence s, the parser is initialized with the configuration c (line 2). Then, a feature function φ(c) represents the configuration c as a vector, which is fed to a scoring function SCORE assigning scores to (configuration,transition) pairs. SCORE c ← ˆ t(c) 6: return tree(c) scores the possible transitions t, and the highest scoring transitionˆttransitionˆ transitionˆt is chosen (line 4). The transitionˆt transitionˆ transitionˆt is applied to the configuration, resulting in a new parser configuration. The process ends when reaching a final configuration, from which the resulting parse tree is read and returned (line 6).</p><p>Transition systems differ by the way they define configurations, and by the particular set of transitions available to them. A parser is determined by the choice of a transition system, a feature function φ and a scoring function SCORE. Our choices are detailed below.</p><p>The Arc-Hybrid System Many transition systems exist in the literature. In this work, we use the archybrid transition system ( <ref type="bibr" target="#b24">Kuhlmann et al., 2011)</ref>, which is similar to the more popular arc-standard system <ref type="bibr" target="#b34">(Nivre, 2004</ref>), but for which an efficient dynamic oracle is available ( <ref type="bibr" target="#b9">Goldberg and Nivre, 2012;</ref><ref type="bibr" target="#b10">Goldberg and Nivre, 2013</ref>). In the arc-hybrid system, a configuration c = (σ, β, T ) consists of a stack σ, a buffer β, and a set T of dependency arcs. Both the stack and the buffer hold integer indices pointing to sentence elements. Given a sentence s = w 1 , . . . , w n , t 1 , . . . , t n , the system is initialized with an empty stack, an empty arc set, and β = 1, . . . , n, ROOT , where ROOT is the special root index. Any configuration c with an empty stack and a buffer containing only ROOT is terminal, and the parse tree is given by the arc set T c of c. The archybrid system allows 3 possible transitions, SHIFT, LEFT and RIGHT , defined as:</p><formula xml:id="formula_5">SHIFT[(σ, b 0 |β, T )] = (σ|b 0 , β, T ) LEFT [(σ|s 1 |s 0 , b 0 |β, T )] = (σ|s 1 , b 0 |β, T ∪ {(b 0 , s 0 , )}) RIGHT [(σ|s 1 |s 0 , β, T )] = (σ|s 1 , β, T ∪ {(s 1 , s 0 , )})</formula><p>The SHIFT transition moves the first item of the buffer (b 0 ) to the stack. The LEFT transition removes the first item on top of the stack (s 0 ) and attaches it as a modifier to b 0 with label , adding the arc (b 0 , s 0 , ). The RIGHT transition removes s 0 from the stack and attaches it as a modifier to the next item on the stack (s 1 ), adding the arc (s 1 , s 0 , ). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scoring Function</head><formula xml:id="formula_6">SCORE θ (x, t) = M LP θ (x)[t]</formula><p>Simple Feature Function The feature function φ(c) is typically complex (see Section 2.1). Our feature function is the concatenated BiLSTM vectors of the top 3 items on the stack and the first item on the buffer. I.e., for a configuration c = (. . . |s 2 |s 1 |s 0 , b 0 | . . . , T ) the feature extractor is defined as:</p><formula xml:id="formula_7">φ(c) = v s 2 • v s 1 • v s 0 • v b 0 v i = BILSTM(x 1:n , i)</formula><p>This feature function is rather minimal: it takes into account the BiLSTM representations of s 1 , s 0 and b 0 , which are the items affected by the possible transitions being scored, as well as one extra stack context s 2 . 6 Figure 1 depicts transition scoring with our architecture and this feature function. Note that, unlike previous work, this feature function does not take into account T , the already built structure. The high parsing accuracies in the experimental sections suggest that the BiLSTM encoding is capable of estimating a lot of the missing information based on the provided stack and buffer elements and the sequential content between them.</p><p>While not explored in this work, relying on only four word indices for scoring an action results in very compact state signatures, making our proposed feature representation very appealing for use in transition-based parsers that employ dynamic-programming search <ref type="bibr" target="#b14">(Huang and Sagae, 2010;</ref><ref type="bibr" target="#b24">Kuhlmann et al., 2011</ref>).</p><p>Extended Feature Function One of the benefits of the greedy transition-based parsing framework is precisely its ability to look at arbitrary features from the already built tree. If we allow somewhat less minimal feature function, we could add the BiLSTM vectors corresponding to the right-most and leftmost modifiers of s 0 , s 1 and s 2 , as well as the leftmost modifier of b 0 , reaching a total of 11 BiLSTM vectors. We refer to this as the extended feature set. As we'll see in Section 6, using the extended set does indeed improve parsing accuracies when using pre-trained word embeddings, but has a minimal effect in the fully-supervised case. <ref type="bibr">7</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Details of the Training Algorithm</head><p>The training objective is to set the score of correct transitions above the scores of incorrect transitions. We use a margin-based objective, aiming to maximize the margin between the highest scoring correct action and the highest scoring incorrect action. The hinge loss at each parsing configuration c is defined as:</p><formula xml:id="formula_8">max 0, 1− max to∈G M LP φ(c) [t o ] + max tp∈A\G M LP φ(c) [t p ]</formula><p>where A is the set of possible transitions and G is the set of correct (gold) transitions at the current stage. At each stage of the training process the parser scores the possible transitions A, incurs a loss, selects a transition to follow, and moves to the next configuration based on it. The local losses are summed throughout the parsing process of a sentence, and the parameters are updated with respect to the sum of the losses at sentence boundaries. <ref type="bibr">8</ref> The gradients of the entire network (including the MLP and the BiLSTM) with respect to the sum of the losses are calculated using the backpropagation algorithm. As usual, we perform several training iterations over the training corpus, shuffling the order of sentences in each iteration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error-Exploration and Dynamic Oracle Training</head><p>We follow <ref type="bibr" target="#b10">Goldberg and Nivre (2013)</ref>; <ref type="bibr" target="#b9">Goldberg and Nivre (2012)</ref> in using error exploration training with a dynamic-oracle, which we briefly describe below. At each stage in the training process, the parser assigns scores to all the possible transitions t ∈ A. It then selects a transition, applies it, and moves to the next step. Which transition should be followed? A common approach follows the highest scoring transition that can lead to the gold tree. However, when training in this way the parser sees only configurations that result from following correct actions, and as a result tends to suffer from error propagation at test time. Instead, in error-exploration training the parser follows the highest scoring action in A during training even if this action is incorrect, exposing it to configurations that result from erroneous decisions. This strategy requires defining the set G such that the correct actions to take are well-defined also for states that cannot lead to the gold tree. Such a set G is called a dynamic oracle. We perform error-exploration training using the dynamic-oracle defined by <ref type="bibr" target="#b10">Goldberg and Nivre (2013)</ref>.</p><p>Aggressive Exploration We found that even when using error-exploration, after one iteration the model remembers the training set quite well, and does not make enough errors to make error-exploration effective. In order to expose the parser to more errors, we follow an aggressive-exploration scheme: we sometimes follow incorrect transitions also if they score below correct transitions. Specifically, when the score of the correct transition is greater than that of the wrong transition but the difference is smaller than a margin constant, we chose to follow the incorrect action with probability p agg (we use p agg = 0.1 in our experiments).</p><p>Summary The greedy transition-based parser follows standard techniques from the literature (margin-based objective, dynamic oracle training, error exploration, MLP-based non-linear scoring function). We depart from the literature by replacing the hand-crafted feature function over carefully selected components of the configuration with a concatenation of BiLSTM representations of a few prominent items on the stack and the buffer, and training the BiLSTM encoder jointly with the rest of the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Graph-based Parser</head><p>Graph-based parsing follows the common structured prediction paradigm ( <ref type="bibr" target="#b38">Taskar et al., 2005;</ref><ref type="bibr" target="#b32">McDonald et al., 2005</ref>):</p><formula xml:id="formula_9">predict(s) = arg max y∈Y(s) score global (s, y) score global (s, y) = part∈y score local (s, part)</formula><p>Given an input sentence s (and the corresponding sequence of vectors x 1:n ) we look for the highest- <ref type="figure">Figure 2</ref>: Illustration of the neural model scheme of the graph-based parser when calculating the score of a given parse tree. The parse tree is depicted below the sentence. Each dependency arc in the sentence is scored using an MLP that is fed the BiLSTM encoding of the words at the arc's end points (the colors of the arcs correspond to colors of the MLP inputs above), and the individual arc scores are summed to produce the final score. All the MLPs share the same parameters. The figure depicts a single-layer BiLSTM, while in practice we use two layers. When parsing a sentence, we compute scores for all possible n 2 arcs, and find the best scoring tree using a dynamic-programming algorithm.</p><formula xml:id="formula_10">LST M f x the concat LST M f x brown concat LST M f x fox concat LST M f x jumped concat LST M f x * concat LST M b s 0 LST M b s 1 LST M b s 2 LST M b s 3 LST M b s 4 V the V brown V fox V jumped V * M LP M LP M LP M LP +</formula><p>scoring parse tree y in the space Y(s) of valid dependency trees over s. In order to make the search tractable, the scoring function is decomposed to the sum of local scores for each part independently. In this work, we focus on arc-factored graph based approach presented in <ref type="bibr" target="#b32">McDonald et al. (2005)</ref>. Arc-factored parsing decomposes the score of a tree to the sum of the score of its head-modifier arcs (h, m):</p><formula xml:id="formula_11">parse(s) = arg max y∈Y(s) (h,m)∈y score φ(s, h, m)</formula><p>Given the scores of the arcs the highest scoring projective tree can be efficiently found using Eisner's decoding algorithm (1996). McDonald et al. and most subsequent work estimate the local score of an arc by a linear model parameterized by a weight vector w, and a feature function φ(s, h, m) assigning a sparse feature vector for an arc linking modifier m to head h. We follow <ref type="bibr" target="#b36">Pei et al. (2015)</ref> and replace the linear scoring function with an MLP. The feature extractor φ(s, h, m) is usually complex, involving many elements (see Section 2.1). In contrast, our feature extractor uses merely the BiLSTM encoding of the head word and the mod- </p><formula xml:id="formula_12">M LP (v h • v m ) v i = BIRNN(x 1:n , i)</formula><p>The architecture is illustrated in <ref type="figure">Figure 2</ref>.</p><p>Training The training objective is to set the score function such that correct tree y is scored above incorrect ones. We use a margin-based objective <ref type="bibr">(Mc- Donald et al., 2005;</ref><ref type="bibr" target="#b27">LeCun et al., 2006</ref>), aiming to maximize the margin between the score of the gold tree y and the highest scoring incorrect tree y . We define a hinge loss with respect to a gold tree y as:</p><formula xml:id="formula_13">max 0, 1 − max y =y (h,m)∈y M LP (v h • v m ) + (h,m)∈y M LP (v h • v m )</formula><p>Each of the tree scores is then calculated by activating the MLP on the arc representations. The entire loss can viewed as the sum of multiple neural networks, which is sub-differentiable. We calculate the gradients of the entire network (including to the BiLSTM encoder and word embeddings).</p><p>Labeled Parsing Up to now, we described unlabeled parsing. A possible approach for adding labels is to score the combination of an unlabeled arc (h, m) and its label by considering the label as part of the arc (h, m, ). This results in |Labels|×|Arcs| parts that need to be scored, leading to slow parsing speeds and arguably a harder learning problem. Instead, we chose to first predict the unlabeled structure using the model given above, and then predict the label of each resulting arc. Using this approach, the number of parts stays small, enabling fast parsing.</p><p>The labeling of an arc (h, m) is performed using the same feature representation φ(s, h, m) fed into a different MLP predictor:</p><formula xml:id="formula_14">label(h, m) = arg max ∈labels M LP LBL (v h • v m )[]</formula><p>As before we use a margin based hinge loss. The labeler is trained on the gold trees. <ref type="bibr">9</ref> The BiLSTM encoder responsible for producing v h and v m is shared with the arc-factored parser: the same BiLSTM encoder is used in the parer and the labeler. This sharing of parameters can be seen as an instance of multi-task learning <ref type="bibr">(Caruana, 1997)</ref>. As we show in Section 6, the sharing is effective: training the BiLSTM feature encoder to be good at predicting arc-labels significantly improves the parser's unlabeled accuracy.</p><p>Loss augmented inference In initial experiments, the network learned quickly and overfit the data. In order to remedy this, we found it useful to use loss augmented inference <ref type="bibr" target="#b38">(Taskar et al., 2005</ref>). The intuition behind loss augmented inference is to update against trees which have high model scores and are also very wrong. This is done by augmenting the score of each part not belonging to the gold tree by adding a constant to its score. Formally, the loss transforms as follows:</p><formula xml:id="formula_15">max(0, 1 + score(x, y)− max y =y part∈y (score local (x, part) + 1 part ∈y ))</formula><p>Speed improvements The arc-factored model requires the scoring of n 2 arcs. Scoring is performed using an MLP with one hidden layer, resulting in n 2 matrix-vector multiplications from the input to the hidden layer, and n 2 multiplications from the hidden to the output layer. The first n 2 multiplications involve larger dimensional input and output vectors, and are the most time consuming. Fortunately, these can be reduced to 2n multiplications and n 2 vector additions, by observing that the multiplication</p><formula xml:id="formula_16">W · (v h • v m ) can be written as W 1 · v h + W 2 · v m</formula><p>where W 1 and W 1 are are the first and second half of the matrix W and reusing the products across different pairs. Summary The graph-based parser is straightforward first-order parser, trained with a marginbased hinge-loss and loss-augmented inference. We depart from the literature by replacing the handcrafted feature function with a concatenation of BiLSTM representations of the head and modifier words, and training the BiLSTM encoder jointly with the structured objective. We also introduce a novel multi-task learning approach for labeled parsing by training a second-stage arc-labeler sharing the same BiLSTM encoder with the unlabeled parser.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experiments and Results</head><p>We evaluated our parsing model on English and Chinese data. For comparison purposes we follow the setup of <ref type="bibr" target="#b6">Dyer et al. (2015)</ref>.</p><p>Data For English, we used the Stanford Dependency (SD) ( <ref type="bibr" target="#b5">de Marneffe and Manning, 2008)</ref>   same predicted POS-tags as used in <ref type="bibr" target="#b6">Dyer et al. (2015)</ref>; <ref type="bibr" target="#b1">Chen and Manning (2014)</ref>. This dataset contains a few non-projective trees. Punctuation symbols are excluded from the evaluation. For Chinese, we use the Penn Chinese Treebank 5.1 (CTB5), using the train/test/dev splits of <ref type="bibr" target="#b45">(Zhang and Clark, 2008;</ref><ref type="bibr" target="#b6">Dyer et al., 2015</ref>) with gold partof-speech tags, also following ( <ref type="bibr" target="#b6">Dyer et al., 2015;</ref><ref type="bibr" target="#b1">Chen and Manning, 2014)</ref>.</p><p>When using external word embeddings, we also use the same data as <ref type="bibr" target="#b6">Dyer et al. (2015)</ref>. <ref type="bibr">10</ref> Implementation Details The parsers are implemented in python, using the PyCNN toolkit 11 for neural network training. The code is available at the github repository https://github.com/ elikip/bist-parser. We use the LSTM variant implemented in PyCNN, and optimize using the Adam optimizer ( <ref type="bibr" target="#b18">Kingma and Ba, 2015</ref> The word and POS embeddings e(w i ) and e(p i ) are initialized to random values and trained together with the rest of the parsers' networks. In some experiments, we introduce also pre-trained word embeddings. In those cases, the vector representation of a word is a concatenation of its randomlyinitialized vector embedding with its pre-trained word vector. Both are tuned during training. We use the same word vectors as in <ref type="bibr" target="#b6">Dyer et al. (2015)</ref> During training, we employ a variant of word dropout <ref type="bibr" target="#b16">(Iyyer et al., 2015)</ref>, and replace a word with the unknown-word symbol with probability that is inversely proportional to the frequency of the word. A word w appearing #(w) times in the training corpus is replaced with the unknown symbol with probability p unk (w) = α #(w)+α . If a word was dropped the external embedding of the word is also dropped with probability 0.5.</p><p>We train the parsers for up to 30 iterations, and choose the best model according to the UAS accuracy on the development set.</p><p>Hyperparameter Tuning We performed a very minimal hyper-parameter search with the graph-based parser, and use the same hyper-parameters for both parsers. The hyper-parameters of the final networks used for all the reported experiments are detailed in <ref type="table" target="#tab_4">Table 2</ref>  Main Results <ref type="table" target="#tab_1">Table 1</ref> lists the test-set accuracies of our best parsing models, compared to other state-ofthe-art parsers from the literature. <ref type="bibr">12</ref> It is clear that our parsers are very competitive, despite using very simple parsing architectures and minimal feature extractors. When not using external embeddings, the first-order graph-based parser with 2 features outperforms all other systems that are not using external resources, including the third-order TurboParser. The greedy transition based parser with 4 features also matches or outperforms most other parsers, including the beam-based transition parser with heavily engineered features of Zhang and Nivre (2011) and the Stack-LSTM parser of <ref type="bibr" target="#b6">Dyer et al. (2015)</ref>, as well as the same parser when trained using a dynamic oracle ( . Moving from the simple (4 features) to the extended (11 features) feature set leads to some gains in accuracy for both English and Chinese.</p><p>Interestingly, when adding external word embeddings the accuracy of the graph-based parser degrades. We are not sure why this happens, and leave the exploration of effective semi-supervised parsing with the graph-based model for future work. The greedy parser does manage to benefit from the external embeddings, and using them we also see gains from moving from the simple to the extended feature set. Both feature sets result in very competitive re-12 Unfortunately, many papers still report English parsing results on the deficient Yamada and Matsumoto head rules (PTB-YM) rather than the more modern Stanford-dependencies (PTB-SD). We note that the PTB-YM and PTB-SD results are not strictly comparable, and in our experience the PTB-YM results are usually about half a UAS point higher. sults, with the extended feature set yielding the best reported results for Chinese, and ranked second for English, after the heavily-tuned beam-based parser of <ref type="bibr" target="#b44">Weiss et al. (2015)</ref>.</p><p>Additional Results We perform some ablation experiments in order to quantify the effect of the different components on our best models <ref type="table" target="#tab_6">(Table 3)</ref>  Loss augmented inference is crucial for the success of the graph-based parser, and the multi-task learning scheme for the arc-labeler contributes nicely to the unlabeled scores. Dynamic oracle training yields nice gains for both English and Chinese.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We presented a pleasingly effective approach for feature extraction for dependency parsing based on a BiLSTM encoder that is trained jointly with the parser, and demonstrated its effectiveness by integrating it into two simple parsing models: a greedy transition-based parser and a globally optimized first-order graph-based parser, yielding very competitive parsing accuracies in both cases.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 1</head><label>1</label><figDesc>Greedy transition-based parsing 1: Input: sentence s = w 1 , . . . , x w , t 1 , . . . , t n , parameterized function SCORE θ (·) with param- eters θ. 2: c ← INITIAL(s) 3: while not TERMINAL(c) do 4: ˆ t ← arg max t∈LEGAL(c) SCORE θ φ(c), t 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Traditionally, the scoring func- tion SCORE θ (x, t) is a discriminative linear model of the form SCORE W (x, t) = (W · x)[t]. The lin- earity of SCORE required the feature function φ(·) to encode non-linearities in the form of combination features. We follow Chen and Manning (2014) and replace the linear scoring model with an MLP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>= BIRNN(x 1:n , h) • BIRNN(x 1:n , m) The final model is: parse(s) = arg max y∈Y(s) score global (s, y) = arg max y∈Y(s) (h,m)∈y score φ(s, h, m) = arg max y∈Y(s) (h,m)∈y</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Test-set parsing results of various state-of-the-art parsing systems on the English (PTB) and Chinese (CTB) datasets. The 

systems that use embeddings may use different pre-trained embeddings. English results use predicted POS tags (different systems 
use different taggers), while Chinese results use gold POS tags. PTB-YM: English PTB, Yamada and Matsumoto head rules. 
PTB-SD: English PTB, Stanford Dependencies (different systems may use different versions of the Stanford converter). CTB: 
Chinese Treebank. reranking /blend in Method column indicates a reranking system where the reranker score is interpolated with 
the base-parser's score. The different systems and the numbers reported from them are taken from: ZhangNivre11: (Zhang and 
Nivre, 2011); Martins13: (Martins et al., 2013); Weiss15 (Weiss et al., 2015); Pei15: (Pei et al., 2015); Dyer15 (Dyer et al., 2015); 
Ballesteros16 (Ballesteros et al., 2016); LeZuidema14 (Le and Zuidema, 2014); Zhu15: (Zhu et al., 2015). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>.</head><label></label><figDesc></figDesc><table>Word embedding dimension 
100 
POS tag embedding dimension 
25 
Hidden units in M LP 
100 
Hidden units in M LP LBL 
100 
BI-LSTM Layers 
2 
BI-LSTM Dimensions (hidden/output) 125 / 125 
α (for word dropout) 
0.25 
p agg (for exploration training) 
0.1 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 2 : Hyper-parameter values used in experiments</head><label>2</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>.</head><label></label><figDesc></figDesc><table>PTB 
CTB 
UAS LAS UAS LAS 
Graph (no ext. emb) 93.3 91.0 87.0 85.4 
-POS 
92.9 89.8 80.6 76.8 
-ArcLabeler 
92.7 
-
86.2 
-
-Loss Aug. 
81.3 79.4 52.6 51.7 
Greedy (ext. emb) 
93.8 91.5 87.8 86.0 
-POS 
93.4 91.2 83.4 81.6 
-DynOracle 
93.5 91.4 87.5 85.9 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Ablation experiments results (dev set) for the graph-

based parser without external embeddings and the greedy parser 
with external embeddings and extended feature set. 

</table></figure>

			<note place="foot" n="1"> Structured training of sequence tagging models over RNNbased representations was explored by Chiu and Nichols (2016) and Lample et al. (2016).</note>

			<note place="foot" n="2"> http://www.seas.upenn.edu/~strctlrn/ MSTParser/MSTParser.html</note>

			<note place="foot" n="3"> In all of these neural-network based approaches, the vector representations of words were initialized using pre-trained word-embeddings derived from a large corpus external to the training data. This puts the approaches in the semi-supervised category, making it hard to tease apart the contribution of the automatic feature-combination component from that of the semisupervised component.</note>

			<note place="foot" n="4"> In this work the tag sequence is assumed to be given, and in practice is predicted by an external model. Future work will address relaxing this assumption.</note>

			<note place="foot" n="5"> While the BiLSTM computation is quite efficient as it is, as demonstrated by Lewis et al. (2016), if using a GPU implementation the BiLSTM encoding can be efficiently performed over many of sentences in parallel, making its computation cost almost negligible.</note>

			<note place="foot" n="6"> An additional buffer context is not needed, as b1 is by definition adjacent to b0, a fact that we expect the BiLSTM encoding of b0 to capture. In contrast, b0, s0, s1 and s2 are not necessarily adjacent to each other in the original sentence. 7 We did not experiment with other feature configurations. It is well possible that not all of the additional 7 child encodings are needed for the observed accuracy gains, and that a smaller feature set will yield similar or even better improvements.</note>

			<note place="foot" n="8"> To increase gradient stability and training speed, we simulate mini-batch updates by only updating the parameters when the sum of local losses contains at least 50 non-zero elements. Sums of fewer elements are carried across sentences. This assures us a sufficient number of gradient samples for every update thus minimizing the effect of gradient instability.</note>

			<note place="foot" n="9"> When training the labeled parser, we calculate the structure loss and the labeling loss for each training sentence, and sum the losses prior to computing the gradients.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Training with exploration improves a greedy stack-LSTM parser. CoRR, abs/1603.03793. Rich Caruana. 1997. Multitask learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Ballesteros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="2016-07" />
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="41" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A fast and accurate dependency parser using neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danqi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</title>
		<meeting>the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)<address><addrLine>Doha, Qatar</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2014-10" />
			<biblScope unit="page" from="740" to="750" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Named entity recognition with bidirectional LSTM-CNNs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Jason</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nichols</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note>Transactions of the Association for Computational Linguistics, 4. To appear</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Natural language understanding with distributed representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<idno>abs/1511.07916</idno>
		<imprint>
			<date type="published" when="2015" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Incremental parsing with minimal features using bi-directional LSTM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Cross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 54th Annual Meeting of the Association for Computational Linguistics<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-08" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Stanford dependencies manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marie-Catherine</forename><surname>De Marneffe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Transitionbased dependency parsing with stack long short-term memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Ballesteros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austin</forename><surname>Matthews</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</title>
		<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<publisher>Long Papers</publisher>
			<date type="published" when="2015-07" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="334" to="343" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Three new probabilistic models for dependency parsing: An exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Eisner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th International Conference on Computational Linguistics, Proceedings of the Conference, COLING 1996</title>
		<meeting><address><addrLine>Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-08-05" />
			<biblScope unit="page" from="340" to="345" />
		</imprint>
		<respStmt>
			<orgName>Center for Sprogteknologi</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Finding structure in time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">L</forename><surname>Elman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognitive Science</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="211" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A dynamic oracle for arc-eager dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The COLING 2012 Organizing Committee</title>
		<meeting><address><addrLine>Mumbai, India, December</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="959" to="976" />
		</imprint>
	</monogr>
	<note>Proceedings of COLING 2012</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Training deterministic parsers with non-deterministic oracles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="403" to="414" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A primer on neural network models for natural language processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<idno>abs/1510.00726</idno>
		<imprint>
			<date type="published" when="2015" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Supervised sequence labelling with recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Graves</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
		<respStmt>
			<orgName>Technical University Munich</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Long short-term memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sepp</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jürgen</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1735" to="1780" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Dynamic programming for linear-time incremental parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenji</forename><surname>Sagae</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 48th Annual Meeting of the Association for Computational Linguistics<address><addrLine>Uppsala, Sweden</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2010-07" />
			<biblScope unit="page" from="1077" to="1086" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Opinion mining with deep recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ozan</forename><surname>Irsoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claire</forename><surname>Cardie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</title>
		<meeting>the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)<address><addrLine>Doha, Qatar</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2014-10" />
			<biblScope unit="page" from="720" to="728" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Deep unordered composition rivals syntactic methods for text classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohit</forename><surname>Iyyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Varun</forename><surname>Manjunatha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jordan</forename><surname>Boyd-Graber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hal</forename><surname>Daumé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Iii</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</title>
		<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2015-07" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1681" to="1691" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Visualizing and understanding recurrent networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrej</forename><surname>Karpathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Justin</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fei-Fei</forename><surname>Li</surname></persName>
		</author>
		<idno>abs/1506.02078</idno>
		<imprint>
			<date type="published" when="2015" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Adam: A method for stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Diederik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jimmy</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Conference for Learning Representations</title>
		<meeting>the 3rd International Conference for Learning Representations<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eliyahu</forename><surname>Kiperwasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
				<title level="m">Easy-first dependency parsing with hierarchical tree LSTMs. Transactions of the Association for Computational Linguistics</title>
		<imprint/>
	</monogr>
	<note>4. To appear</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient thirdorder dependency parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 48th Annual Meeting of the Association for Computational Linguistics<address><addrLine>Uppsala, Sweden</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2010-07" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Simple semi-supervised dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xavier</forename><surname>Carreras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 46th Annual Meeting of the Association for Computational Linguistics<address><addrLine>Columbus, Ohio</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2008-06" />
			<biblScope unit="page" from="595" to="603" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Dependency Parsing. Synthesis Lectures on Human Language Technologies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandra</forename><surname>Kübler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><forename type="middle">T</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Morgan &amp; Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Dynamic programming algorithms for transition-based dependency parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kuhlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Gómez-Rodríguez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giorgio</forename><surname>Satta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies<address><addrLine>Portland, Oregon, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2011-06" />
			<biblScope unit="page" from="673" to="682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Neural architectures for named entity recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Lample</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Ballesteros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandeep</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kazuya</forename><surname>Kawakami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Dyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2016-06" />
			<biblScope unit="page" from="260" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The insideoutside recursive neural network model for dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phong</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willem</forename><surname>Zuidema</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</title>
		<meeting>the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)<address><addrLine>Doha, Qatar</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2014-10" />
			<biblScope unit="page" from="729" to="739" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A tutorial on energy-based learning. Predicting structured data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raia</forename><surname>Hadsell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fu Jie Huang ; Tao</forename><surname>Marc&amp;apos;aurelio Ranzato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuan</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regina</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tommi</forename><surname>Barzilay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jaakkola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 52nd Annual Meeting of the Association for Computational Linguistics<address><addrLine>Baltimore, Maryland</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1381" to="1391" />
		</imprint>
	</monogr>
	<note>Low-rank tensors for scoring dependency structures</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">LSTM CCG parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenton</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2016-06" />
			<biblScope unit="page" from="221" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Building a large annotated corpus of English: The Penn Treebank</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename><forename type="middle">P</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Beatrice</forename><surname>Santorini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><forename type="middle">Ann</forename><surname>Marcinkiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="313" to="330" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Concise integer linear programming formulations for dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andre</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Xing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP</title>
		<meeting>the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP<address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2009-08" />
			<biblScope unit="page" from="342" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Turning on the turbo: Fast third-order nonprojective turbo parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andre</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 51st Annual Meeting of the Association for Computational Linguistics<address><addrLine>Sofia, Bulgaria</addrLine></address></meeting>
		<imprint>
			<publisher>Short Papers</publisher>
			<date type="published" when="2013-08" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="617" to="622" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Online large-margin training of dependency parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koby</forename><surname>Crammer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fernando</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL&apos;05)</title>
		<meeting>the 43rd Annual Meeting of the Association for Computational Linguistics (ACL&apos;05)<address><addrLine>Ann Arbor, Michigan</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2005-06" />
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Discriminative Training and Spanning Tree Algorithms for Dependency Parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Incrementality in deterministic dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACL Workshop Incremental Parsing: Bringing Engineering and Cognition Together</title>
		<editor>Frank Keller, Stephen Clark, Matthew Crocker, and Mark Steedman</editor>
		<meeting>the ACL Workshop Incremental Parsing: Bringing Engineering and Cognition Together<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-07" />
			<biblScope unit="page" from="50" to="57" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Algorithms for deterministic incremental dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="513" to="553" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">An effective neural network model for graph-based dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenzhe</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baobao</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</title>
		<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2015-07" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="313" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Bidirectional recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuldip</forename><forename type="middle">K</forename><surname>Paliwal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Signal Processing</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2673" to="2681" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Learning structured prediction models: A large margin approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Taskar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vassil</forename><surname>Chatalbashev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daphne</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning, Proceedings of the Twenty-Second International Conference (ICML 2005)</title>
		<meeting><address><addrLine>Bonn, Germany, Au</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="896" to="903" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Template kernels for dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hillel</forename><surname>Taub-Tabib</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amir</forename><surname>Globerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies<address><addrLine>Denver, Colorado</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2015-05" />
			<biblScope unit="page" from="1422" to="1427" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A latent variable model for generative dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivan</forename><surname>Titov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Henderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth International Conference on Parsing Technologies</title>
		<meeting>the Tenth International Conference on Parsing Technologies<address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2007-06" />
			<biblScope unit="page" from="144" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Supertagging with LSTMs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yonatan</forename><surname>Bisk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenji</forename><surname>Sagae</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Musa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Annual Conference of the North</title>
		<meeting>the 15th Annual Conference of the North</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">American</forename><surname>Chapter</surname></persName>
		</author>
		<title level="m">the Association for Computational Linguistics (Short Papers)</title>
		<meeting><address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Grammar as a foreign language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lukasz</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slav</forename><surname>Petrov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<idno>De- cember 7-12</idno>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems</title>
		<meeting><address><addrLine>Montreal, Quebec, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2773" to="2781" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Structured training for neural network transition-based parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Alberti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slav</forename><surname>Petrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</title>
		<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-07" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="323" to="333" />
		</imprint>
	</monogr>
	<note>Long Papers). Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A tale of two parsers: Investigating and combining graph-based and transition-based dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2008 Conference on Empirical Methods in Natural Language Processing<address><addrLine>Honolulu, Hawaii</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-10" />
			<biblScope unit="page" from="562" to="571" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Transition-based dependency parsing with rich non-local features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies<address><addrLine>Portland, Oregon, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-06" />
			<biblScope unit="page" from="188" to="193" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A re-ranking model for dependency parser with recursive convolutional neural network</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenxi</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xipeng</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinchi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuanjing</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</title>
		<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2015-07" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1159" to="1168" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
